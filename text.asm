section .data

    message1:  db "Полдень прошел?(Y/N)",0xa,0 ;сообщение вопроса, адрес начала строки
    ln1 equ $-message1                          ;длина сообщения
                                                  ;0xa - перенос строки
                                                  ;0 - не обязателен, но иногда может понадобиться, например при работе с C

    message2: db 0xa,"Доброе утро!",0xa,0               ;сообщение ответа, адрес начала строки
    ln2 equ $-message2                          ;длина сообщения

    message3:  db 0xa,"Добрый день!",0xa,0               ;сообщение ответа, адрес начала строки
    ln3 equ $-message3                          ;длина сообщения

    message4:  db 0xa,"Введите Y или N",0xa,0               ;сообщение ответа, адрес начала строки
    ln4 equ $-message4                          ;длина сообщения

    enter: resb 1                                ;выделение памяти в 1 байт переменной enter
    lne equ $-enter                            ;длина сообщения


;начало самой программы
section .text
    global _start
    _start:

;действия для вывода содержимого по умолчанию с началом в ecx, с длиной edx - вывод вопроса
mov ecx, message1       ;в ecx помещается адрес первого символа переменной
mov edx, ln1            ;в edx помещается количество символов в переменной
mov eax,4       ;эта строка №1 обязательна для вывода!
mov ebx,1       ;эта строка №2 обязательна для вывода!
int 0x80        ;эта строка №3 обязательна для вывода!


;действия для ввода содержимого по умолчанию с началом в ecx, с длиной edx - ввод ответа
mov eax, 3         ;эта строка №1 обязательна для ввода!
mov ebx, 0         ;эта строка №2 обязательна для ввода!

;mov ecx, enter   ;в ecx помещается адрес первого символа из enter
mov edx, lne       ;в edx помещается количество символов в переменной, остальные заполнятся нулями

int 0x80           ;эта строка №3 обязательна для ввода!



;push rcx    ;из регистра rcx отправляем значение в стек; ax-для 16b ,eax-для 32b,rcx-для 64b систем,
;pop rcx     ;из стека помещаем значение в регистр ecx


;действия для вывода содержимого по умолчанию с началом в ecx, с длиной edx - вывод ответа
mov eax,4       ;эта строка №1 обязательна для вывода!
mov ebx,1       ;эта строка №2 обязательна для вывода!
int 0x80        ;эта строка №3 обязательна для вывода!

;увеличение содержимого по этому адресу на значение 1
;add byte [ecx],1;

;действия для сравнения содержимого
 cmp byte [ecx], 'Y';при вводе данных через клавиатуру в ecx помещается адрес первого символа из всех существующих
                        ;поэтому при выводе надо указывать ecx в квадратных скобках, так как это адрес символа  [ecx]
                        ;и обязательно указывать размер, в данном случае byte, так как изначально резервировался размер в байтах resb


    je m1                 ;если введено Y
    jne m2                 ;если введено не Y

m1:                      ;переходит сюда, если введено 1

    mov ecx,message2
    mov edx,ln2
    jmp exit              ;переход к метке exit


m2:            ;переходит сюда, если введено не Y
cmp byte [ecx], 'N';при вводе данных через клавиатуру в ecx помещается адрес первого символа из всех существующих
je m3                 ;если введено N
jne m4                 ;если введено не N

m3:
    mov ecx,message3
    mov edx,ln3
    jmp exit              ;переход к метке exit

  m4:
        mov ecx,message4
        mov edx,ln4
        jmp _start              ;переход к метке _start


exit:
;вывод содержимого ecx
mov eax,4       ;эта строка №1 обязательна для вывода!
mov ebx,1       ;эта строка №2 обязательна для вывода!
int 0x80        ;эта строка №3 обязательна для вывода!

mov ax,1             ;выход
    int 0x80
